<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Sky6 by wangfakang</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Sky6</h1>
        <p class="header">analysis Load balancing algorithm　</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/wangfakang/sky6/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/wangfakang/sky6/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/wangfakang/sky6">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/wangfakang">wangfakang</a></p>


      </header>
      <section>
        <p><code>nginx load balancing algorithm 的分析：
</code></p>

<h1>
<a id="内容" class="anchor" href="#%E5%86%85%E5%AE%B9" aria-hidden="true"><span class="octicon octicon-link"></span></a>内容：</h1>

<h1>
<a id="nginx--round_robin-ip_hashchash_hash的解析" class="anchor" href="#nginx--round_robin-ip_hashchash_hash%E7%9A%84%E8%A7%A3%E6%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>nginx  round_robin 、ip_hash、chash_hash的解析</h1>

<h1>
<a id="round_robin" class="anchor" href="#round_robin" aria-hidden="true"><span class="octicon octicon-link"></span></a>round_robin：</h1>

<pre><code>round_robin是nginx默认采用的后端peer选择的算法（在ngx_http_upstream_init_main_conf
函数中有一个函数指针peer.init_upstream若在nginx的配置文件中upstream未指定相应的算
法则设置为init_round_robin函数），然后函数init_round_robin会做一些初始化后端peer的
工作以及设置peer.init指向init_round_robin_peer函数。当每一个请求来的时候调用
ngx_http_upstream_init_request的时候就会调用init_round_robin_peer函数（主要作用是
设置peer.get   peer.free函数以及开辟round_robin数据结构空间进行相应的赋值）其中get
主要是根据其算法选择后端一个server、然后进行测试后端是否可以连接、不可以则选择下一个。   
</code></pre>

<ul>
<li>其选择的规则是： </li>
</ul>

<pre><code>其会有三个值：weight、curent_weight、effective_weight、total_weight，其中
effective_weight等于weight，curent_weight初始化0。total_weight的值是每一次
选择的过程中是各个effective_weight的总和，每一次轮训玩后置为0。每次curent_weight
的值是加上effective_weight的值。每次都是选择current_weight值最大的一个，
每次选中过后都会把curent_weight的值减去total_weight的值（间接降低权值），若
选择到的peer在进行测试连接失败的话则会把当前的effective_weight  -=  weight/max_fails .
当服务恢复正常的时候并且effective_weight小于weight的时候又会让effective_weight的值加1.
从而达到负载均衡的选择server。

</code></pre>

<h1>
<a id="ip_hash---" class="anchor" href="#ip_hash---" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ip_hash：   </h1>

<pre><code>Ip_hash 在调用init_ip_hash的时候其内部也在调用init_round_robin_peer（初始化后端peer）原因
是ip_hash的数据结构中也有一个peers结构体最后其实就是使用init_round_robin中的那个、然后设
置peer.init=init_ip_hash_peer，当每一个请求来的时候调用ngx_http_upstream_init_request的
时候就会调用init_ip_hash_peer函数（主要作用是设置peer.get   peer.free函数以及开辟iphp数
据结构空间进行相应的赋值,并且设置iphp中的Get_rr_peer函数指针为get_round_robin_peer函数）
根据ip的类型设置iphp数据结构中的addr以及addrlen（IPV4中设置addr为ip的前面三个字节）。   
</code></pre>

<ul>
<li>
<p>选取规则：   </p>

<pre><code>首先判断根据ip_hash方法进行选取的失败次数是否超过20次或是后端只有一个peer的时候就调用
开始设置的 get_rr_peer（round_robin算法），否则的话就根据ip前3个字段进行hash，其函数是：
 Hash  =  (hash*113 + iphp-&gt;addr[i])%6271   
最后得到hash值得时候在去判断 weighted（weighted = （w != n））的值是不是0，当weighted的值是0的
时候表示weight的值是1  即虚拟节点数等于ip数，直接hash%peers-&gt;number就ok了，否则选择最先则使得
为0的那个如下：
 for(I = 0 ; i&lt;peers-&gt;numbers;i++  ) {   
       w -= peers-&gt;peer[i].weight;    
       if w &lt; 0 break;     

最后就选择peer[i] 然后进行测试连接是否可以连接。   

</code></pre>
</li>
</ul>

<h1>
<a id="consisten_hash---" class="anchor" href="#consisten_hash---" aria-hidden="true"><span class="octicon octicon-link"></span></a>Consisten_hash：   </h1>

<pre><code>
一致性hash算法主要思想就是把后端peer全部映射到一个环上，然后当有一个请求到达的时候也根据其
请求的ip或是url或是其请求参数使用同样的hash函数去找，其中查找的算法使用的是二分法查找，比如
有A、B、C三个server形成一个环当来一个request的时候其hash到了A与B之间其就映射到B上去，当然有
一个问题就是当A与B很近的时候C就占了很大的空间于是一致性hash就引入了虚拟节点的说法，其nginx内
部的虚拟节点就是根据其weight值做的（weight的值乘以160）。假如A的weight的值是2则在这个环上就
根据hash值得大小排序成320个节点从而达到更均衡。其实nginx内部的具体做法不是这么简单的：使用
了一个叫做chash_peer_data_t 的结构体uchpd，其中有一个servers就是存放了所有的后端peer其中的顺
序是根据hash值进行从小到大排序的（内部是包括虚拟节点的，其排序算法使用的插入排序法，由于插入排
序是一个稳定的排序算法），然后还有一个real_node是一个三级指针，其中存放的是每一个真实server
所对应的虚拟peer（实际是存放的servers中的）其主要作用就是快速hash更新某一个server的状态值（
如当servers中有一个server down了 就要标志所有的server的相关虚拟节点的值也是down 但是servers
中的server顺序是hash值排序的，但是知道真实server的index所以借助这个index直接定位到real_node
中直接全部更新），然后根据client的hash值选择一个server（二分法查找）,当查找到的节点正好是down
的是时候就会把这个节点放入一个队列当中，然后在把这个节点从segment树中删除，然后借助segment树
进行去检查找一个最接近hash值得节点，然后接着进行后续处理然后下一个节点来的时候先判断这个队列
中的server是否已经恢复了若恢复了则把其节点从队列中删除，插入segment树中共后续查找。 
</code></pre>

<h1>
<a id="三种hash策略的比较--" class="anchor" href="#%E4%B8%89%E7%A7%8Dhash%E7%AD%96%E7%95%A5%E7%9A%84%E6%AF%94%E8%BE%83--" aria-hidden="true"><span class="octicon octicon-link"></span></a>三种hash策略的比较：  </h1>

<pre><code>首先hash（ip_hash、consistent_hash）与round_robin的直接区别就是:前面两种算法定位后端server
的时候与来的请求很相关，同一个client多次请求会让一台后端server处理（若次server不异常的话），
而round_robin算法则同一client的不同请求时间定位到后端的server也不同是与请求无关的（若是作
为缓存或是session机制的话就选择hash）。后面说说ip_hash与consisten_hash的比较：ip_hash（配置文件中的down特定，backup对其无效）采用的hash算法没有consistent_hash算法灵活（ip_hash一般只是根据client的请求ip，而chash可以根据client的ip、url、以及请求参数进行hash，consistent_hash会 
定期的检查之前down掉的机器，若是其server正常了则恢复到环中更新down标志）  

</code></pre>

<h2>
<a id="有问题反馈" class="anchor" href="#%E6%9C%89%E9%97%AE%E9%A2%98%E5%8F%8D%E9%A6%88" aria-hidden="true"><span class="octicon octicon-link"></span></a>有问题反馈</h2>

<p>在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流</p>

<ul>
<li>邮件(1031379296#qq.com, 把#换成@)</li>
<li>QQ: 1031379296</li>
<li>weibo: <a href="http://weibo.com/u/2786211992/home">@王发康</a>
</li>
</ul>

<h2>
<a id="感激" class="anchor" href="#%E6%84%9F%E6%BF%80" aria-hidden="true"><span class="octicon octicon-link"></span></a>感激</h2>

<h3>
<a id="chunshengsteratgmailcom" class="anchor" href="#chunshengsteratgmailcom" aria-hidden="true"><span class="octicon octicon-link"></span></a>chunshengsterATgmail.com</h3>

<h2>
<a id="关于作者" class="anchor" href="#%E5%85%B3%E4%BA%8E%E4%BD%9C%E8%80%85" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于作者</h2>

<h3>
<a id="linuxnginxgolangcc爱好者" class="anchor" href="#linuxnginxgolangcc%E7%88%B1%E5%A5%BD%E8%80%85" aria-hidden="true"><span class="octicon octicon-link"></span></a>Linux\nginx\golang\c\c++爱好者</h3>

<h3>
<a id="欢迎一起交流--一起学习" class="anchor" href="#%E6%AC%A2%E8%BF%8E%E4%B8%80%E8%B5%B7%E4%BA%A4%E6%B5%81--%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0" aria-hidden="true"><span class="octicon octicon-link"></span></a>欢迎一起交流  一起学习#</h3>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		          <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("nginx Load balancing algorithm");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
